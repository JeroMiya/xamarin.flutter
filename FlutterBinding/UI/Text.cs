using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using static FlutterBinding.Mapping.Helper;

namespace FlutterBinding.UI
{
    /// Whether to slant the glyphs in the font
    public enum FontStyle
    {
        /// Use the upright glyphs
        Normal,

        /// Use glyphs designed for slanting
        Italic,
    }

    /// The thickness of the glyphs used to draw the text
    public class FontWeight
    {
        private FontWeight(int index)
        {
            Index = index;
        }

        /// The encoded integer value of this font weight.
        public readonly int Index;

        /// Thin, the least thick
        public static readonly FontWeight W100 = new FontWeight(0);

        /// Extra-light
        public static readonly FontWeight W200 = new FontWeight(1);

        /// Light
        public static readonly FontWeight W300 = new FontWeight(2);

        /// Normal / regular / plain
        public static readonly FontWeight W400 = new FontWeight(3);

        /// Medium
        public static readonly FontWeight W500 = new FontWeight(4);

        /// Semi-bold
        public static readonly FontWeight W600 = new FontWeight(5);

        /// Bold
        public static readonly FontWeight W700 = new FontWeight(6);

        /// Extra-bold
        public static readonly FontWeight W800 = new FontWeight(7);

        /// Black, the most thick
        public static readonly FontWeight W900 = new FontWeight(8);

        /// The default font weight.
        public static readonly FontWeight Normal = W400;

        /// A commonly used font weight that is heavier than normal.
        public static readonly FontWeight Bold = W700;

        /// A list of all the font weights.
        public static readonly List<FontWeight> Values = new List<FontWeight>
        {
            W100, W200, W300, W400, W500, W600, W700, W800, W900
        };

        /// Linearly interpolates between two font weights.
        ///
        /// Rather than using fractional weights, the interpolation rounds to the
        /// nearest weight.
        ///
        /// Any null values for `a` or `b` are interpreted as equivalent to [normal]
        /// (also known as [w400]).
        ///
        /// The `t` argument represents position on the timeline, with 0.0 meaning
        /// that the interpolation has not started, returning `a` (or something
        /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
        /// returning `b` (or something equivalent to `b`), and values in between
        /// meaning that the interpolation is at the relevant point on the timeline
        /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
        /// 1.0, so negative values and values greater than 1.0 are valid (and can
        /// easily be generated by curves such as [Curves.elasticInOut]). The result
        /// is clamped to the range [w100]–[w900].
        ///
        /// Values for `t` are usually obtained from an [Animation<double>], such as
        /// an [AnimationController].
        public static FontWeight Lerp(FontWeight a, FontWeight b, double t)
        {
            //assert(t != null);
            return Values[(int)UI.Lerp.lerpDouble(a?.Index ?? Normal.Index, b?.Index ?? Normal.Index, t).round().clamp(0, 8)];
        }

        public override string ToString()
        {
            return new Dictionary<int, string>
            {
                {0, "FontWeight.W100"},
                {1, "FontWeight.W200"},
                {2, "FontWeight.W300"},
                {3, "FontWeight.W400"},
                {4, "FontWeight.W500"},
                {5, "FontWeight.W600"},
                {6, "FontWeight.W700"},
                {7, "FontWeight.W800"},
                {8, "FontWeight.W900"},
            }[Index];
        }
    }

    /// Whether and how to align text horizontally.
    // The order of this enum must match the order of the values in RenderStyleConstants.h's ETextAlign.
    public enum TextAlign
    {
        /// Align the text on the left edge of the container.
        Left,

        /// Align the text on the right edge of the container.
        Right,

        /// Align the text in the center of the container.
        Center,

        /// Stretch lines of text that end with a soft line break to fill the width of
        /// the container.
        ///
        /// Lines that end with hard line breaks are aligned towards the [start] edge.
        Justify,

        /// Align the text on the leading edge of the container.
        ///
        /// For left-to-right text ([TextDirection.ltr]), this is the left edge.
        ///
        /// For right-to-left text ([TextDirection.rtl]), this is the right edge.
        Start,

        /// Align the text on the trailing edge of the container.
        ///
        /// For left-to-right text ([TextDirection.ltr]), this is the right edge.
        ///
        /// For right-to-left text ([TextDirection.rtl]), this is the left edge.
        End,
    }

    /// A horizontal line used for aligning text.
    public enum TextBaseline
    {
        /// The horizontal line used to align the bottom of glyphs for alphabetic characters.
        Alphabetic,

        /// The horizontal line used to align ideographic characters.
        Ideographic,
    }

    /// The style in which to draw a text decoration
    public enum TextDecorationStyle
    {
        /// Draw a solid line
        Solid,

        /// Draw two lines
        Double,

        /// Draw a dotted line
        Dotted,

        /// Draw a dashed line
        Dashed,

        /// Draw a sinusoidal line
        Wavy
    }

    [Flags]
    public enum TextDecoration
    {
        None = 0x0,
        Underline = 0x01,
        Overline = 0x02,
        LineThrough = 0x04
    }


    /// A direction in which text flows.
    ///
    /// Some languages are written from the left to the right (for example, English,
    /// Tamil, or Chinese), while others are written from the right to the left (for
    /// example Aramaic, Hebrew, or Urdu). Some are also written in a mixture, for
    /// example Arabic is mostly written right-to-left, with numerals written
    /// left-to-right.
    ///
    /// The text direction must be provided to APIs that render text or lay out
    /// boxes horizontally, so that they can determine which direction to start in:
    /// either right-to-left, [TextDirection.rtl]; or left-to-right,
    /// [TextDirection.ltr].
    ///
    /// ## Design discussion
    ///
    /// Flutter is designed to address the needs of applications written in any of
    /// the world's currently-used languages, whether they use a right-to-left or
    /// left-to-right writing direction. Flutter does not support other writing
    /// modes, such as vertical text or boustrophedon text, as these are rarely used
    /// in computer programs.
    ///
    /// It is common when developing user interface frameworks to pick a default
    /// text direction — typically left-to-right, the direction most familiar to the
    /// engineers working on the framework — because this simplifies the development
    /// of applications on the platform. Unfortunately, this frequently results in
    /// the platform having unexpected left-to-right biases or assumptions, as
    /// engineers will typically miss places where they need to support
    /// right-to-left text. This then results in bugs that only manifest in
    /// right-to-left environments.
    ///
    /// In an effort to minimize the extent to which Flutter experiences this
    /// category of issues, the lowest levels of the Flutter framework do not have a
    /// default text reading direction. Any time a reading direction is necessary,
    /// for example when text is to be displayed, or when a
    /// writing-direction-dependent value is to be interpreted, the reading
    /// direction must be explicitly specified. Where possible, such as in `switch`
    /// statements, the right-to-left case is listed first, to avoid the impression
    /// that it is an afterthought.
    ///
    /// At the higher levels (specifically starting at the widgets library), an
    /// ambient [Directionality] is introduced, which provides a default. Thus, for
    /// instance, a [Text] widget in the scope of a [MaterialApp] widget does not
    /// need to be given an explicit writing direction. The [Directionality.of]
    /// static method can be used to obtain the ambient text direction for a
    /// particular [BuildContext].
    ///
    /// ### Known left-to-right biases in Flutter
    ///
    /// Despite the design intent described above, certain left-to-right biases have
    /// nonetheless crept into Flutter's design. These include:
    ///
    ///  * The [Canvas] origin is at the top left, and the x-axis increases in a
    ///    left-to-right direction.
    ///
    ///  * The default localization in the widgets and material libraries is
    ///    American English, which is left-to-right.
    ///
    /// ### Visual properties vs directional properties
    ///
    /// Many classes in the Flutter framework are offered in two versions, a
    /// visually-oriented variant, and a text-direction-dependent variant. For
    /// example, [EdgeInsets] is described in terms of top, left, right, and bottom,
    /// while [EdgeInsetsDirectional] is described in terms of top, start, end, and
    /// bottom, where start and end correspond to right and left in right-to-left
    /// text and left and right in left-to-right text.
    ///
    /// There are distinct use cases for each of these variants.
    ///
    /// Text-direction-dependent variants are useful when developing user interfaces
    /// that should "flip" with the text direction. For example, a paragraph of text
    /// in English will typically be left-aligned and a quote will be indented from
    /// the left, while in Arabic it will be right-aligned and indented from the
    /// right. Both of these cases are described by the direction-dependent
    /// [TextAlign.start] and [EdgeInsetsDirectional.start].
    ///
    /// In contrast, the visual variants are useful when the text direction is known
    /// and not affected by the reading direction. For example, an application
    /// giving driving directions might show a "turn left" arrow on the left and a
    /// "turn right" arrow on the right — and would do so whether the application
    /// was localized to French (left-to-right) or Hebrew (right-to-left).
    ///
    /// In practice, it is also expected that many developers will only be
    /// targeting one language, and in that case it may be simpler to think in
    /// visual terms.
    // The order of this enum must match the order of the values in TextDirection.h's TextDirection.
    public enum TextDirection
    {
        /// The text flows from right to left (e.g. Arabic, Hebrew).
        Rtl,

        /// The text flows from left to right (e.g., English, French).
        Ltr,
    }

    /// Whether a [TextPosition] is visually upstream or downstream of its offset.
    ///
    /// For example, when a text position exists at a line break, a single offset has
    /// two visual positions, one prior to the line break (at the end of the first
    /// line) and one after the line break (at the start of the second line). A text
    /// affinity disambiguates between those cases. (Something similar happens with
    /// between runs of bidirectional text.)
    public enum TextAffinity
    {
        /// The position has affinity for the upstream side of the text position.
        ///
        /// For example, if the offset of the text position is a line break, the
        /// position represents the end of the first line.
        Upstream,

        /// The position has affinity for the downstream side of the text position.
        ///
        /// For example, if the offset of the text position is a line break, the
        /// position represents the start of the second line.
        Downstream,
    }

    public static class Text
    {
        /// Loads a font from a buffer and makes it available for rendering text.
        ///
        /// * `list`: A list of bytes containing the font file.
        /// * `fontFamily`: The family name used to identify the font in text styles.
        ///  If this is not provided, then the family name will be extracted from the font file.
        public static Task LoadFontFromList(List<int> list, string fontFamily = "")
        {
            return _futurize(
                () =>
                {
                    _loadFontFromList(list, fontFamily);
                });
        }

        private static void _loadFontFromList(List<int> list, string fontFamily)
        {
            // native 'loadFontFromList';
        }
    }
}
